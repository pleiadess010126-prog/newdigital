// =============================================================================
// MARKETING AUTOPILOT - Automated Campaign Creation & Execution
// =============================================================================
// Extends the base autopilot with marketing-specific automation:
// - Automatic email/SMS campaign creation
// - AI-powered content generation
// - Smart scheduling based on AI predictions
// - Recurring campaign templates
// - Integration with Collaboration Engine for approval workflows
// =============================================================================

import { prisma } from '@/lib/db/prisma';
import { getPredictiveEngine } from './predictive';
import { getCollaborationEngine } from '@/lib/collaboration/engine';

// =============================================================================
// TYPES
// =============================================================================

export interface MarketingAutopilotConfig {
    organizationId: string;
    enabled: boolean;

    // AI Content Generation
    contentGeneration: {
        enabled: boolean;
        brandVoice: 'professional' | 'casual' | 'friendly' | 'formal' | 'playful';
        autoApprove: boolean;
        maxPerWeek: number;
    };

    // Automated Triggers
    triggers: {
        welcomeEmail: boolean;
        reEngagement: boolean;
        churnPrevention: boolean;
        birthdayEmail: boolean;
        purchaseFollowup: boolean;
    };

    // Recurring Campaigns
    recurringCampaigns: RecurringCampaignTemplate[];

    // Smart Scheduling  
    scheduling: {
        useAITiming: boolean;
        timezone: string;
        blackoutStart: number;
        blackoutEnd: number;
        blackoutDays: number[];
    };

    // Safety Limits
    limits: {
        maxEmailsPerContact: number;
        maxSmsPerContact: number;
        requireApprovalAbove: number;
    };
}

export interface RecurringCampaignTemplate {
    id: string;
    name: string;
    type: 'email' | 'sms';
    frequency: 'daily' | 'weekly' | 'monthly';
    dayOfWeek?: number;
    dayOfMonth?: number;
    hour: number;
    subject?: string;
    contentPrompt: string;
    audience: 'all' | 'active' | 'inactive' | 'leads' | 'customers';
    enabled: boolean;
    lastRun?: string;
}

export interface AutoGeneratedCampaign {
    id: string;
    name: string;
    type: 'email' | 'sms';
    subject?: string;
    content: string;
    audience: string;
    audienceSize: number;
    scheduledFor: string;
    status: 'pending' | 'approved' | 'scheduled' | 'sent';
    trigger: string;
    aiConfidence: number;
    createdAt: string;
}

// =============================================================================
// DEFAULT CONFIG
// =============================================================================

export const DEFAULT_MARKETING_AUTOPILOT: Omit<MarketingAutopilotConfig, 'organizationId'> = {
    enabled: false,
    contentGeneration: {
        enabled: true,
        brandVoice: 'professional',
        autoApprove: false,
        maxPerWeek: 5,
    },
    triggers: {
        welcomeEmail: true,
        reEngagement: true,
        churnPrevention: true,
        birthdayEmail: false,
        purchaseFollowup: false,
    },
    recurringCampaigns: [],
    scheduling: {
        useAITiming: true,
        timezone: 'UTC',
        blackoutStart: 22,
        blackoutEnd: 7,
        blackoutDays: [0, 6],
    },
    limits: {
        maxEmailsPerContact: 3,
        maxSmsPerContact: 4,
        requireApprovalAbove: 500,
    },
};

// =============================================================================
// CONTENT TEMPLATES
// =============================================================================

const EMAIL_TEMPLATES = {
    welcome: [
        {
            subject: 'Welcome to {{brand}}! üéâ',
            content: `Hi {{firstName}},

Welcome aboard! We're thrilled to have you join our community.

Here's what you can expect:
‚Ä¢ Exclusive updates and offers
‚Ä¢ Insider tips and tricks  
‚Ä¢ Priority access to new features

If you have any questions, we're just a reply away!

Best,
The {{brand}} Team`,
        },
        {
            subject: '{{firstName}}, your journey starts now!',
            content: `Hey {{firstName}}!

Thanks for signing up! You've just joined thousands of others who trust us.

To get started:
1. Complete your profile
2. Explore our features
3. Join our community

Let's make great things happen together!`,
        },
    ],
    reEngagement: [
        {
            subject: 'We miss you, {{firstName}}! üíî',
            content: `Hi {{firstName}},

We noticed you haven't visited us in a while, and we just wanted to check in.

A lot has changed since you last stopped by:
‚Ä¢ New features you'll love
‚Ä¢ Improved experience
‚Ä¢ Special comeback offer just for you

We'd love to have you back!`,
        },
    ],
    churnPrevention: [
        {
            subject: 'Is everything okay? We want to help',
            content: `Hi {{firstName}},

We noticed your activity has dropped recently, and we wanted to reach out.

Your success is our priority. If there's anything we can do to improve your experience, please let us know.

Here's a special offer to help: {{offer}}

We're always here to help!`,
        },
    ],
    promotional: [
        {
            subject: 'üî• Limited Time: {{offer}}',
            content: `Hi {{firstName}},

We've got something special just for you!

For a limited time, enjoy exclusive savings. This is your chance to get more for less.

‚è∞ Hurry - this offer expires {{expiry}}!

Shop now and save!`,
        },
    ],
};

const SMS_TEMPLATES = {
    welcome: ['Welcome to {{brand}}! üéâ Get started: {{link}}'],
    reEngagement: ['We miss you {{firstName}}! üíî Come back for a special surprise: {{link}}'],
    promotional: ['üî• FLASH SALE! {{discount}}% off for 24hrs only: {{link}}'],
};

// =============================================================================
// MARKETING AUTOPILOT ENGINE
// =============================================================================

export class MarketingAutopilotEngine {
    private config: MarketingAutopilotConfig;
    private predictiveEngine: ReturnType<typeof getPredictiveEngine>;

    constructor(config: MarketingAutopilotConfig) {
        this.config = config;
        this.predictiveEngine = getPredictiveEngine(config.organizationId);
    }

    /**
     * Check if autopilot can run right now
     */
    canRun(): boolean {
        if (!this.config.enabled) return false;

        const now = new Date();
        const hour = now.getHours();
        const day = now.getDay();

        // Check blackout hours
        const { blackoutStart, blackoutEnd } = this.config.scheduling;
        if (blackoutStart > blackoutEnd) {
            if (hour >= blackoutStart || hour < blackoutEnd) return false;
        } else {
            if (hour >= blackoutStart && hour < blackoutEnd) return false;
        }

        // Check blackout days
        if (this.config.scheduling.blackoutDays.includes(day)) return false;

        return true;
    }

    /**
     * ASI GATEKEEPER: Validates content against strict safety/compliance rules.
     * Blocks any content that fails, even if auto-approve is ON.
     */
    validateSafeContent(content: string): { safe: boolean; reason?: string } {
        // 1. Legal Check: Unverified Superlatives
        if (content.toLowerCase().includes('#1') || content.toLowerCase().includes('number one')) {
            return { safe: false, reason: "Legal Alert: Unverified '#1' claim detected. Must use 'Leading' or provide citation." };
        }

        // 2. Financial Compliance: Guaranteed Returns
        if (content.toLowerCase().includes('guaranteed return') || content.toLowerCase().includes('guaranteed profit')) {
            return { safe: false, reason: "Compliance Alert: 'Guaranteed' financial promises are prohibited." };
        }

        // 3. Brand Safety: Competitor Attacks
        // (Placeholder for AI check)

        // Passed all checks
        return { safe: true };
    }

    /**
     * Run the autopilot - process all triggers and recurring campaigns
     * When autoApprove is ON, campaigns are created AND sent automatically
     */
    async run(): Promise<{
        campaignsCreated: AutoGeneratedCampaign[];
        campaignsSent: AutoGeneratedCampaign[];
        actions: string[];
    }> {
        const result: {
            campaignsCreated: AutoGeneratedCampaign[];
            campaignsSent: AutoGeneratedCampaign[];
            actions: string[];
        } = {
            campaignsCreated: [],
            campaignsSent: [],
            actions: [],
        };

        if (!this.canRun()) {
            result.actions.push('‚è∏Ô∏è Autopilot paused - outside operating hours');
            return result;
        }

        result.actions.push('üöÄ Autopilot running...');

        // Process welcome emails
        if (this.config.triggers.welcomeEmail) {
            const welcome = await this.processWelcomeEmails();
            if (welcome) {
                // ASI GATEKEEPER CHECK
                const safety = this.validateSafeContent(welcome.content);

                if (!safety.safe) {
                    welcome.status = 'pending'; // Force to pending even if auto-approve is on
                    this.submitToApprovalQueue(welcome); // Send to War Room for review
                    result.actions.push(`‚õî BLOCKED BY WAR ROOM: Complience Alert (${safety.reason}). Sent to manual review.`);
                }
                else {
                    result.campaignsCreated.push(welcome);
                    result.actions.push(`‚úâÔ∏è Created welcome campaign for ${welcome.audienceSize} new contacts`);

                    // If auto-approve is ON, send immediately (Full Auto Mode)
                    if (this.config.contentGeneration.autoApprove) {
                        const sent = await this.sendCampaign(welcome);
                        if (sent) {
                            welcome.status = 'sent';
                            result.campaignsSent.push(welcome);
                            result.actions.push(`üöÄ AUTO-SENT: Welcome campaign to ${welcome.audienceSize} contacts`);
                        }
                    } else {
                        // Submit to Collaboration queue for human approval
                        this.submitToApprovalQueue(welcome);
                        result.actions.push(`üìã Submitted to approval queue: ${welcome.name}`);
                    }
                }
            }
        }

        // Process re-engagement
        if (this.config.triggers.reEngagement) {
            const reEngage = await this.processReEngagement();
            if (reEngage) {
                result.campaignsCreated.push(reEngage);
                result.actions.push(`üíå Created re-engagement campaign for ${reEngage.audienceSize} contacts`);

                if (this.config.contentGeneration.autoApprove) {
                    const sent = await this.sendCampaign(reEngage);
                    if (sent) {
                        reEngage.status = 'sent';
                        result.campaignsSent.push(reEngage);
                        result.actions.push(`üöÄ AUTO-SENT: Re-engagement campaign to ${reEngage.audienceSize} contacts`);
                    }
                } else {
                    this.submitToApprovalQueue(reEngage);
                    result.actions.push(`üìã Submitted to approval queue: ${reEngage.name}`);
                }
            }
        }

        // Process churn prevention
        if (this.config.triggers.churnPrevention) {
            const churn = await this.processChurnPrevention();
            if (churn) {
                result.campaignsCreated.push(churn);
                result.actions.push(`üõ°Ô∏è Created churn prevention campaign for ${churn.audienceSize} contacts`);

                if (this.config.contentGeneration.autoApprove) {
                    const sent = await this.sendCampaign(churn);
                    if (sent) {
                        churn.status = 'sent';
                        result.campaignsSent.push(churn);
                        result.actions.push(`üöÄ AUTO-SENT: Churn prevention campaign to ${churn.audienceSize} contacts`);
                    }
                } else {
                    this.submitToApprovalQueue(churn);
                    result.actions.push(`üìã Submitted to approval queue: ${churn.name}`);
                }
            }
        }

        // Process recurring campaigns
        for (const template of this.config.recurringCampaigns) {
            if (template.enabled && this.shouldRunRecurring(template)) {
                const campaign = await this.createFromTemplate(template);
                if (campaign) {
                    result.campaignsCreated.push(campaign);
                    result.actions.push(`üìÖ Created recurring campaign: ${template.name}`);

                    if (this.config.contentGeneration.autoApprove) {
                        const sent = await this.sendCampaign(campaign);
                        if (sent) {
                            campaign.status = 'sent';
                            result.campaignsSent.push(campaign);
                            result.actions.push(`üöÄ AUTO-SENT: ${template.name}`);
                        }
                    }
                }
            }
        }

        // Summary
        if (this.config.contentGeneration.autoApprove) {
            result.actions.push(`‚úÖ FULL AUTOPILOT: ${result.campaignsCreated.length} created, ${result.campaignsSent.length} sent automatically`);
        } else {
            result.actions.push(`‚úÖ Autopilot complete - ${result.campaignsCreated.length} campaigns awaiting approval`);
        }

        return result;
    }

    /**
     * Actually send a campaign (email or SMS)
     */
    async sendCampaign(campaign: AutoGeneratedCampaign): Promise<boolean> {
        try {
            // Get contacts for this campaign
            let contacts: Array<{ id: string; email: string; phone?: string | null; firstName?: string | null }> = [];

            if (campaign.audience.includes('New contacts')) {
                contacts = await prisma.contact.findMany({
                    where: {
                        organizationId: this.config.organizationId,
                        createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) },
                    },
                    select: { id: true, email: true, phone: true, firstName: true },
                    take: this.config.limits.maxEmailsPerContact > 0 ? 500 : 100,
                });
            } else if (campaign.audience.includes('Inactive')) {
                contacts = await prisma.contact.findMany({
                    where: {
                        organizationId: this.config.organizationId,
                        lastActivityAt: { lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) },
                        status: 'active',
                    },
                    select: { id: true, email: true, phone: true, firstName: true },
                    take: 500,
                });
            } else if (campaign.audience.includes('At-risk')) {
                contacts = await prisma.contact.findMany({
                    where: {
                        organizationId: this.config.organizationId,
                        leadScore: { lt: 30 },
                    },
                    select: { id: true, email: true, phone: true, firstName: true },
                    take: 100,
                });
            }

            if (contacts.length === 0) {
                console.log(`[Autopilot] No contacts found for campaign: ${campaign.name}`);
                return false;
            }

            // Personalize and send
            console.log(`[Autopilot] üöÄ SENDING ${campaign.type.toUpperCase()} to ${contacts.length} contacts`);

            for (const contact of contacts) {
                // Personalize content
                const personalizedContent = campaign.content
                    .replace(/{{firstName}}/g, contact.firstName || 'there')
                    .replace(/{{brand}}/g, 'DigitalMEng')
                    .replace(/{{link}}/g, 'https://app.digitalmeng.com');

                const personalizedSubject = campaign.subject
                    ?.replace(/{{firstName}}/g, contact.firstName || 'there')
                    .replace(/{{brand}}/g, 'DigitalMEng');

                if (campaign.type === 'email') {
                    // In production: await sendEmail({ to: contact.email, subject, content })
                    console.log(`[Autopilot] üìß Email to ${contact.email}: ${personalizedSubject}`);
                } else if (campaign.type === 'sms' && contact.phone) {
                    // In production: await sendSMS({ to: contact.phone, message: personalizedContent })
                    console.log(`[Autopilot] üì± SMS to ${contact.phone}: ${personalizedContent.substring(0, 50)}...`);
                }
            }

            console.log(`[Autopilot] ‚úÖ Campaign "${campaign.name}" sent to ${contacts.length} contacts`);
            return true;
        } catch (error) {
            console.error(`[Autopilot] ‚ùå Failed to send campaign: ${(error as Error).message}`);
            return false;
        }
    }

    /**
     * Submit campaign to Collaboration approval queue
     */
    submitToApprovalQueue(campaign: AutoGeneratedCampaign): void {
        try {
            const collaborationEngine = getCollaborationEngine(this.config.organizationId);

            collaborationEngine.submitForApproval({
                type: campaign.type === 'email' ? 'email_campaign' : 'sms_campaign',
                title: campaign.name,
                description: `AI-generated ${campaign.type} campaign for ${campaign.audience}`,
                content: JSON.stringify({
                    subject: campaign.subject,
                    body: campaign.content,
                    audience: campaign.audience,
                    audienceSize: campaign.audienceSize,
                    scheduledFor: campaign.scheduledFor,
                }),
                metadata: {
                    trigger: campaign.trigger,
                    aiConfidence: campaign.aiConfidence,
                    originalCampaign: campaign,
                },
                source: 'autopilot',
                aiConfidence: campaign.aiConfidence,
                createdBy: 'ai-autopilot',
                priority: campaign.audienceSize > 100 ? 'high' : 'medium',
            });

            console.log(`[Autopilot] üìã Submitted "${campaign.name}" to approval queue`);
        } catch (error) {
            console.error(`[Autopilot] ‚ùå Failed to submit to approval queue: ${(error as Error).message}`);
        }
    }

    /**
     * Generate content using AI (templates for demo)
     */
    async generateContent(
        type: 'welcome' | 'reEngagement' | 'churnPrevention' | 'promotional',
        channel: 'email' | 'sms'
    ): Promise<{ subject?: string; content: string }> {
        const templates = channel === 'email' ? EMAIL_TEMPLATES : SMS_TEMPLATES;
        const options = templates[type] || templates.promotional;
        const selected = options[Math.floor(Math.random() * options.length)];

        if (channel === 'email') {
            return { subject: (selected as any).subject, content: (selected as any).content };
        } else {
            return { content: selected as string };
        }
    }

    /**
     * Get optimal send time from AI
     */
    async getOptimalSendTime(): Promise<Date> {
        if (!this.config.scheduling.useAITiming) {
            // Default to next business hour
            const next = new Date();
            next.setHours(10, 0, 0, 0);
            if (next <= new Date()) next.setDate(next.getDate() + 1);
            return next;
        }

        const times = await this.predictiveEngine.getOptimalSendTime();
        if (times.length === 0) {
            const next = new Date();
            next.setHours(10, 0, 0, 0);
            return next;
        }

        const best = times[0];
        const next = new Date();
        let daysUntil = best.dayOfWeek - next.getDay();
        if (daysUntil <= 0) daysUntil += 7;
        next.setDate(next.getDate() + daysUntil);
        next.setHours(best.hour, 0, 0, 0);
        return next;
    }

    private async processWelcomeEmails(): Promise<AutoGeneratedCampaign | null> {
        try {
            const newContacts = await prisma.contact.findMany({
                where: {
                    organizationId: this.config.organizationId,
                    createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) },
                },
                take: 100,
            });

            if (newContacts.length === 0) return null;

            const content = await this.generateContent('welcome', 'email');
            const sendTime = await this.getOptimalSendTime();

            return {
                id: `auto_${Date.now()}`,
                name: `Welcome Campaign - ${new Date().toLocaleDateString()}`,
                type: 'email',
                subject: content.subject,
                content: content.content,
                audience: 'New contacts (24h)',
                audienceSize: newContacts.length,
                scheduledFor: sendTime.toISOString(),
                status: this.config.contentGeneration.autoApprove ? 'scheduled' : 'pending',
                trigger: 'New Contact',
                aiConfidence: 0.92,
                createdAt: new Date().toISOString(),
            };
        } catch {
            return null;
        }
    }

    private async processReEngagement(): Promise<AutoGeneratedCampaign | null> {
        try {
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            const inactiveContacts = await prisma.contact.findMany({
                where: {
                    organizationId: this.config.organizationId,
                    lastActivityAt: { lt: thirtyDaysAgo },
                    status: 'active',
                },
                take: 100,
            });

            if (inactiveContacts.length === 0) return null;

            const content = await this.generateContent('reEngagement', 'email');
            const sendTime = await this.getOptimalSendTime();

            return {
                id: `auto_${Date.now()}`,
                name: `Re-Engagement Campaign - ${new Date().toLocaleDateString()}`,
                type: 'email',
                subject: content.subject,
                content: content.content,
                audience: 'Inactive 30+ days',
                audienceSize: inactiveContacts.length,
                scheduledFor: sendTime.toISOString(),
                status: this.config.contentGeneration.autoApprove ? 'scheduled' : 'pending',
                trigger: 'Inactivity',
                aiConfidence: 0.85,
                createdAt: new Date().toISOString(),
            };
        } catch {
            return null;
        }
    }

    private async processChurnPrevention(): Promise<AutoGeneratedCampaign | null> {
        try {
            const atRiskContacts = await prisma.contact.findMany({
                where: {
                    organizationId: this.config.organizationId,
                    lastActivityAt: { lt: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000) },
                    leadScore: { lt: 30 },
                },
                take: 50,
            });

            if (atRiskContacts.length === 0) return null;

            const content = await this.generateContent('churnPrevention', 'email');
            const sendTime = await this.getOptimalSendTime();

            return {
                id: `auto_${Date.now()}`,
                name: `Churn Prevention - ${new Date().toLocaleDateString()}`,
                type: 'email',
                subject: content.subject,
                content: content.content,
                audience: 'At-risk contacts',
                audienceSize: atRiskContacts.length,
                scheduledFor: sendTime.toISOString(),
                status: 'pending',
                trigger: 'Churn Risk',
                aiConfidence: 0.78,
                createdAt: new Date().toISOString(),
            };
        } catch {
            return null;
        }
    }

    private shouldRunRecurring(template: RecurringCampaignTemplate): boolean {
        if (!template.lastRun) return true;

        const lastRun = new Date(template.lastRun);
        const now = new Date();

        switch (template.frequency) {
            case 'daily':
                return now.getDate() !== lastRun.getDate();
            case 'weekly':
                return now.getDay() === template.dayOfWeek && now.getDate() !== lastRun.getDate();
            case 'monthly':
                return now.getDate() === template.dayOfMonth && now.getMonth() !== lastRun.getMonth();
            default:
                return false;
        }
    }

    private async createFromTemplate(template: RecurringCampaignTemplate): Promise<AutoGeneratedCampaign | null> {
        const content = await this.generateContent('promotional', template.type);
        const sendTime = new Date();
        sendTime.setHours(template.hour, 0, 0, 0);

        return {
            id: `auto_${Date.now()}`,
            name: `${template.name} - ${new Date().toLocaleDateString()}`,
            type: template.type,
            subject: template.subject || content.subject,
            content: content.content,
            audience: template.audience,
            audienceSize: 0, // Would be calculated
            scheduledFor: sendTime.toISOString(),
            status: this.config.contentGeneration.autoApprove ? 'scheduled' : 'pending',
            trigger: 'Recurring',
            aiConfidence: 0.90,
            createdAt: new Date().toISOString(),
        };
    }
}

// =============================================================================
// SINGLETON MANAGEMENT
// =============================================================================

const configs = new Map<string, MarketingAutopilotConfig>();
const pendingCampaigns = new Map<string, AutoGeneratedCampaign[]>();

export function getMarketingAutopilotConfig(orgId: string): MarketingAutopilotConfig {
    let config = configs.get(orgId);
    if (!config) {
        config = { ...DEFAULT_MARKETING_AUTOPILOT, organizationId: orgId };
        configs.set(orgId, config);
    }
    return config;
}

export function updateMarketingAutopilotConfig(
    orgId: string,
    updates: Partial<MarketingAutopilotConfig>
): MarketingAutopilotConfig {
    const current = getMarketingAutopilotConfig(orgId);
    const updated = { ...current, ...updates, organizationId: orgId };
    configs.set(orgId, updated);
    return updated;
}

export function getMarketingAutopilotEngine(orgId: string): MarketingAutopilotEngine {
    const config = getMarketingAutopilotConfig(orgId);
    return new MarketingAutopilotEngine(config);
}

export function getPendingCampaigns(orgId: string): AutoGeneratedCampaign[] {
    return pendingCampaigns.get(orgId) || [];
}

export function addPendingCampaign(orgId: string, campaign: AutoGeneratedCampaign): void {
    const current = pendingCampaigns.get(orgId) || [];
    current.push(campaign);
    pendingCampaigns.set(orgId, current);
}

export function approveCampaign(orgId: string, campaignId: string): boolean {
    const current = pendingCampaigns.get(orgId) || [];
    const campaign = current.find(c => c.id === campaignId);
    if (campaign) {
        campaign.status = 'approved';
        return true;
    }
    return false;
}
